# MySQL 面试题总结

##### 1. Mysql 事务特性（ACID）都有哪些？具体含义是什么？



##### 2. Mysql 事务隔离级别都有哪些？各个隔离级别之间区别是什么？



##### 3. 简述一下 Mysql 索引的底层实现原理。



##### 4. 简述一下你对 MVCC 的理解。

`MVCC`就是多版本并发控制实现对数据库的并发访问。`MVCC`解决的问题是读写互相不阻塞的问题，每次更新都产生一个新的版本，读的话可以读历史版本。`MVCC`是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。

在MySQL的Innodb引擎中就是指在`读已提交(RC)`和`可重复读(RR)`这两种隔离级别下的事务对于`SELECT`操作会访问版本链中的记录的过程。这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。 InnoDB只查找版本`trx_id`早于当前事务版本的数据行。

> 在InnoDB引擎表中，它的记录中有两个必要的隐藏列：
>
> `trx_id` 用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。
>
> `roll_pointer` 对记录有修改的时候，都会把老版本写入`undo log`中。这个roll_pointer就是存了一个指针，它指向这条记录的上一个版本的位置，通过它来获得上一个版本的记录信息。

##### 5. 简要叙述下 binlog、redo log、undo log 之间的关系？

MySQL 日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属 binlog（二进制日志 ）和 事务日志 redo log（重做日志）和 undo log（回滚日志）。

**（1）redo log**

`redo log`：记录`Innodb`存储引擎的事务日志，将**数据页上修改**的内容记录下来，用于数据恢复。（Innodb引擎级别的文件）

当数据库发生故障的时候，通过对`redo log`日志重放，更新磁盘上的数据页，即可保证数据库的数据完整。

> redo log 工作原理：
>
> `MySQL` 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 `Buffer Pool` 中。
>
> 后续的查询都是先从 `Buffer Pool` 中找，没有命中再去硬盘加载，减少硬盘 `IO` 开销，提升性能。
>
> 更新表数据的时候，也是如此，发现 `Buffer Pool` 里存在要更新的数据，就直接在 `Buffer Pool` 里更新。
>
> 然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（`redo log buffer`）里，接着刷盘到 `redo log` 文件里。

​                                                                                                                                                                                                                                             **（2）bin log**

`bin log`：记录了 MySQL 数据库**执行修改的所有操作**，主要用于同步数据库和恢复数据库。（MySQL数据库级别的文件）

MySQL 数据库的**数据备份、主备、主主、主从**都离不开 `bin log`，需要依靠 `bin log` 来同步数据，保证数据一致性。

**（3）undo log**

`undo log`: 将事务修改前的数据记录下来，用于数据撤回。

在进行事务回滚时，可以根据`undo log`回溯到某个特定版本的数据，实现MVCC。

> 另外，`MVCC` 的实现依赖于：**隐藏字段、Read View、undo log**。在内部实现中，`InnoDB` 通过数据行的 `DB_TRX_ID` 和 `Read View` 来判断数据的可见性，如不可见，则通过数据行的 `DB_ROLL_PTR` 找到 `undo log` 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 `Read View` 之前已经提交的修改和该事务本身做的修改

**Tips:**

> **`binlog`和`redo log `的数据一致性的保证**采用了两阶段提交：9i                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                
>
> **为了保证 binlog 和 redo log 的数据一致性，MySQL 采用两阶段提交，此时 binlog 和 redo log 的刷盘策略必须设置为双1。**redo log刷盘策略为`1`时， 只要事务提交成功，`redo log`记录就一定在硬盘里，不会有任何数据丢失。binlog刷盘策略设置为`1`，表示每次提交事务都会执行`fsync`，就如同 redo log 日志刷盘                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         流程一样。
>
> **两阶段提交（2PC）是什么？** 两阶段提交将分布式事务分成了两个阶段，两个阶段分别为 **准备阶段** 和 **提交阶段** 。
>
> 1、当 `redo log `没有写完后，系统崩溃。此时，当重放 `redo log` 时，没有检测到 `prepare` 标记，会回滚事务。此时 `bin log` 也没有写入，二者数据保持一致
> 2、当 `redo log` 写入`prepare` 标记后，还未写完 `binlog` 时系统崩溃。此时也会回滚事务。二者的数据保持一致。
> 3、当 binlog 也写完后，事务提交时系统崩溃，此时需要查看 redo log 是否写完整，如果 `redo log` 有`commit`标记，则提交事务。如果 `redo log` 没有 `commit` 标记，则要查看`binlog`对应的 `commit` 标记，如果 `bin log` 有`commit` 标记，则提交事务，如果没有`commit`标记则回滚事务。二者的数据仍保持一致。

> **事务的回滚** 采用了两阶段提交：
>
> **准备阶段**：事务管理器给每个参与者发送 `prepare` 消息，每个数据库参与者在本地执行事务，并写入`undo log`、`redo log`，此时事务没有提交。（`undo log` 记录修改前的数据，用于数据回滚；`redo log` 用于记录修改后的数据，用于提交事务后写入的数据）。
> **提交阶段**：如果事务管理器接收到了参与者的失败信息或者超时，则直接给每个参与者发送回滚`Rollback`消息，否则发送提交`Commit`消息；参与者根据事务管理器的指令执行提交或者回滚，并释放事务过程中使用的锁资源。





